<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Summary of 'Clean Architecture' by Robert C. Martin | Yannick Grenzinger</title><meta name=keywords content="book summary,architecture,code"><meta name=description content="Uncle Bob, the well known author of Clean Code, is coming back to us with a new book called Clean Architecture which wants to take a larger view on how to create software.
Even if Clean Code is one of the major book around OOP and code design (mainly by presenting the SOLID principles), I was not totally impressed by the book.
Clean Architecture leaves me with the same feeling, even if it&rsquo;s pushing the development world to do better, has some good stories and present robust principles to build software."><meta name=author content="Yannick Grenzinger"><link rel=canonical href=https://ygrenzinger.github.io/posts/clean-architecture-summary/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ygrenzinger.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ygrenzinger.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ygrenzinger.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ygrenzinger.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ygrenzinger.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.99.1"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Summary of 'Clean Architecture' by Robert C. Martin"><meta property="og:description" content="Uncle Bob, the well known author of Clean Code, is coming back to us with a new book called Clean Architecture which wants to take a larger view on how to create software.
Even if Clean Code is one of the major book around OOP and code design (mainly by presenting the SOLID principles), I was not totally impressed by the book.
Clean Architecture leaves me with the same feeling, even if it&rsquo;s pushing the development world to do better, has some good stories and present robust principles to build software."><meta property="og:type" content="article"><meta property="og:url" content="https://ygrenzinger.github.io/posts/clean-architecture-summary/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-31T00:00:00+00:00"><meta property="article:modified_time" content="2017-12-31T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Summary of 'Clean Architecture' by Robert C. Martin"><meta name=twitter:description content="Uncle Bob, the well known author of Clean Code, is coming back to us with a new book called Clean Architecture which wants to take a larger view on how to create software.
Even if Clean Code is one of the major book around OOP and code design (mainly by presenting the SOLID principles), I was not totally impressed by the book.
Clean Architecture leaves me with the same feeling, even if it&rsquo;s pushing the development world to do better, has some good stories and present robust principles to build software."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ygrenzinger.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Summary of 'Clean Architecture' by Robert C. Martin","item":"https://ygrenzinger.github.io/posts/clean-architecture-summary/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Summary of 'Clean Architecture' by Robert C. Martin","name":"Summary of \u0027Clean Architecture\u0027 by Robert C. Martin","description":"Uncle Bob, the well known author of Clean Code, is coming back to us with a new book called Clean Architecture which wants to take a larger view on how to create software.\nEven if Clean Code is one of the major book around OOP and code design (mainly by presenting the SOLID principles), I was not totally impressed by the book.\nClean Architecture leaves me with the same feeling, even if it\u0026rsquo;s pushing the development world to do better, has some good stories and present robust principles to build software.","keywords":["book summary","architecture","code"],"articleBody":"Uncle Bob, the well known author of Clean Code, is coming back to us with a new book called Clean Architecture which wants to take a larger view on how to create software.\nEven if Clean Code is one of the major book around OOP and code design (mainly by presenting the SOLID principles), I was not totally impressed by the book.\nClean Architecture leaves me with the same feeling, even if it’s pushing the development world to do better, has some good stories and present robust principles to build software.\nThe book is build around 34 chapters organised in chapters.\nProgramming paradigm After some introduction, there is an overview of three paradigm of programming:\n structured programming which imposes discipline on direct transfer of control object oriented programming which imposes discipline on indirect transfer of control functional programming which imposes discipline upon assignment  Uncle Bob tells us that each of these paradigm remove something from us (goto statement, function pointers and assignment) and especially tells us what not to do, not what to do. For OOP, he insists on polymorphism which brings us to dependancy inversion. DI allows the source code dependancy (the inheritance relationship) to points in the invert direction compared to the flow of control. Design Principles This chapter present us the SOLID principles, yes the ones from Clean Code. The most important one is the dependancy inversion principle which is the pillar of the clean architecture. It will become the Dependancy Rule. The second one is Single Responsibility Principle which will become the Common Closure Principle at architectural level. Interesting thing about SRP, Uncle Bob redefines it as : “A module should be responsible to one, and only one, actor”.\nComponent Principles We start to gain height. The book begins to talk about component which are the units of deployment like jar files, DLLs or even services and introduce three new principles for component cohesion :\n the Reuse / Release Equivalence Principle (RRP) : the granularity of reuse is the granularity of release the Common Closure Principle (CCP) : gather into components those classes that change for the same reasons and at the same times (related to SRP) the Common Reuse Principle (CRP) : don’t force users of a component to depend on things they don’t need (related to ISP) We see that these higher principles are very similar to the SOLID ones. Finally if you understand well the SOLID principles, there are nothing really new.  However there is a very interesting thing called the tension diagram, a triangle formed by these 3 principles.. This diagram shows that these three principles interact with each other and the difficulty is to place your component inside this triangle. The REP and CCP are inclusive principles : both tend to make component larger. The CRP is an exclusive principle, driving components to be smaller. Uncle Bob advises us to focus on CCP than REP on early stage of development because develop-ability is more important than reuse.\nThe next three principles deal with the coupling between components:\n the Acyclic Dependancies Principles. As soon as you begin using component, you should allow no cycles in the dependancy graph. It’s always possible to break a cycle with Dependancy Inversion Principles. Important note : the component structure cannot be designed from the top down, it evolves as the system grows. Component dependancy diagrams are a map to the build-ability and maintainability of the application. the Stable Dependencies Principle. Some components are designed to be volatile. We expect them to change. Any of these should not depend on a component that is difficult to change. We should depend in the direction of stability. Again employing the DIP can help us to apply this principle breaking dependency on a stable component. the Stable Abstractions Principle. A component should be as abstract as it is stable. The software should encapsulates the high level policies (business rules) of the system into stable component. Those policies will become difficult to change. So how to make them flexible enough to withstand change ? By using Open Closed Principle and Abstract classes (personal note : I am not convinced by this advice of abstract classes …). So the SDP says that dependencies should run in the direction of stability and the SAP says that stability implies abstraction. So dependencies should run in the direction of abstraction.  Some links:\n Summary of all these principles Slides : Principles of Package Design Slides : OOD Principles and Patterns  Architecture Uncle Bob views on architecture is somewhat different of the typical architect. For him, an architect continues to be a programmer. They may not write as much code but they continue to engage in programming tasks. They do this because they cannot do their jobs if they are not experiencing the problems that they are creating for the rest of the programmer.\nThe architecture of a software system is the shape given it by those who build it. The purpose of that shape is to facilitate development, deployment, operation and maintenance. The main strategy is to leave as many options as possible, for as long as possible. We should carefully separate policy from the details at the point that policy has no knowledge of the details. In more pragmatic words, the business rules should not depend on the technical details of implementation.\nThis leads us to draw boundary lines between components. Some of the components are core business rules, other are plugins that contains technical implementations. The DIP and SAP principles arrange dependency to point from lower-level details to higher-level abstractions (toward the core business).\nThe architecture chapters leads us to the Clean Architecture which is clearly the main advice of the book. Clean Architecture push us to separate stable business rules (higher-level abstractions) from volatile technical details (lower-level details), defining clear boundaries. The main building block is the Dependency Rule : source code dependencies must point only inward, toward higher-level policies.\nIt should have the following characteristics:\n Testable Independent of frameworks Independent of the UI Independent of the database Independent of any external agency  This proposal is in fact build on the same ideas than Hexagonal Architecture which proposed by Alistair Cockburn in 2005 and is more and more well known. Maybe because I am accustomed to it, Hexagonal Architecture proposition is more lean and straight to the point for me.\nSome links to discover Hexagonal Architecture\n http://fideloper.com/hexagonal-architecture http://tpierrain.blogspot.fr/2016/04/hexagonal-layers.html Videos of meetup around hexgonal architecture in Paris  Interesting note from Uncle Bob, implementing many boundaries could be costly to implement (with all their abstractions and dependency inversions). So it’s a real design decision. You don’t simply decide at the start which boundaries to implement and which to ignore. It takes a watchful eye to monitor the system and introduce needed boundaries.\nDetails In the last part and associated chapters, Uncle bob talks about technical details like Database, the Web or Frameworks and insists their are only details on which decisions should be delayed as far as possible.\nThere is also a case study and a chapter by Simon Brown which compare different code organisation : package by layer, feature or component. Most ideas can be found in this article of Simon Brown.\nConclusion I am a bit disappointed by Clean architecture. Of course, it presents must known principles (SOLID) and build from them to present the “component” principles for software architecture (CCP, RRP, CRP, ADP, SAP, SDP). it also push strong opinions which I totally agree (like Software Architects should keep coding) and a Clean Architecture software structure which is very good structure. However why not keep the hexagonal architecture proposal and propose improvements if necessary ?\nMy main feeling is that the book could easily summarised in a hundred of pages (the book is more than 350 pages). I think it could be made clearer and more straightforward. The design of the book leaves also an “old school” impression (what are these horrible chapter images ?). It also comes from the many old stories that want to bring some historical context on the subjet (but it could interest some people and brings some “old wisdom”).\n","wordCount":"1352","inLanguage":"en","datePublished":"2017-12-31T00:00:00Z","dateModified":"2017-12-31T00:00:00Z","author":{"@type":"Person","name":"Yannick Grenzinger"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ygrenzinger.github.io/posts/clean-architecture-summary/"},"publisher":{"@type":"Organization","name":"Yannick Grenzinger","logo":{"@type":"ImageObject","url":"https://ygrenzinger.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ygrenzinger.github.io/ accesskey=h title="Yannick Grenzinger (Alt + H)">Yannick Grenzinger</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ygrenzinger.github.io/about title=About><span>About</span></a></li><li><a href=https://ygrenzinger.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ygrenzinger.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ygrenzinger.github.io/archives title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Summary of 'Clean Architecture' by Robert C. Martin</h1><div class=post-meta><span title="2017-12-31 00:00:00 +0000 UTC">December 31, 2017</span>&nbsp;·&nbsp;Yannick Grenzinger&nbsp;|&nbsp;<a href=https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/clean-architecture-summary.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Uncle Bob, the well known author of Clean Code, is coming back to us with a new book called Clean Architecture which wants to take a larger view on how to create software.</p><p>Even if Clean Code is one of the major book around OOP and code design (mainly by presenting the SOLID principles), I was not totally impressed by the book.</p><p>Clean Architecture leaves me with the same feeling, even if it&rsquo;s pushing the development world to do better, has some good stories and present robust principles to build software.</p><p>The book is build around 34 chapters organised in chapters.</p><h2 id=programming-paradigm>Programming paradigm<a hidden class=anchor aria-hidden=true href=#programming-paradigm>#</a></h2><p>After some introduction, there is an overview of three paradigm of programming:</p><ul><li>structured programming which imposes discipline on direct transfer of control</li><li>object oriented programming which imposes discipline on indirect transfer of control</li><li>functional programming which imposes discipline upon assignment</li></ul><p>Uncle Bob tells us that each of these paradigm remove something from us (goto statement, function pointers and assignment) and especially tells us what not to do, not what to do. For OOP, he insists on polymorphism which brings us to <a href=https://mikhail.io/2016/05/dependency-inversion-implies-interfaces-are-owned-by-high-level-modules/>dependancy inversion</a>. DI allows the source code dependancy (the inheritance relationship) to points in the invert direction compared to the flow of control.
<img loading=lazy src=https://mikhail.io/2016/05/dependency-inversion-implies-interfaces-are-owned-by-high-level-modules//uml-dependency-inversion-with-dependency-injection.png alt="Dependancy Inversion" title="Dependency Inversion"></p><h2 id=design-principles>Design Principles<a hidden class=anchor aria-hidden=true href=#design-principles>#</a></h2><p>This chapter present us the SOLID principles, yes the ones from Clean Code. The most important one is the dependancy inversion principle which is the pillar of the clean architecture. It will become the Dependancy Rule. The second one is Single Responsibility Principle which will become the Common Closure Principle at architectural level. Interesting thing about SRP, Uncle Bob redefines it as : &ldquo;A module should be responsible to one, and only one, actor&rdquo;.</p><h2 id=component-principles>Component Principles<a hidden class=anchor aria-hidden=true href=#component-principles>#</a></h2><p>We start to gain height. The book begins to talk about component which are the units of deployment like jar files, DLLs or even services and introduce three new principles for component cohesion :</p><ul><li>the Reuse / Release Equivalence Principle (RRP) : the granularity of reuse is the granularity of release</li><li>the Common Closure Principle (CCP) : gather into components those classes that change for the same reasons and at the same times (related to SRP)</li><li>the Common Reuse Principle (CRP) : don&rsquo;t force users of a component to depend on things they don&rsquo;t need (related to ISP)
We see that these higher principles are very similar to the SOLID ones. Finally if you understand well the SOLID principles, there are nothing really new.</li></ul><p>However there is a very interesting thing called the <a href=https://www.codingblocks.net/podcast/clean-architecture-components-and-component-cohesion/>tension diagram</a>, a triangle formed by these 3 principles.. This diagram shows that these three principles interact with each other and the difficulty is to place your component inside this triangle.
The REP and CCP are inclusive principles : both tend to make component larger. The CRP is an exclusive principle, driving components to be smaller.
<img loading=lazy src=https://www.codingblocks.net/wp-content/uploads/2017/12/CohesionPrinciplesTensionDiagram.jpg alt="Tension Diagram" title="Tension Diagram"></p><p>Uncle Bob advises us to focus on CCP than REP on early stage of development because develop-ability is more important than reuse.</p><p>The next three principles deal with the coupling between components:</p><ul><li>the Acyclic Dependancies Principles. As soon as you begin using component, you should allow no cycles in the dependancy graph. It&rsquo;s always possible to break a cycle with Dependancy Inversion Principles. Important note : the component structure cannot be designed from the top down, it evolves as the system grows. Component dependancy diagrams are a map to the build-ability and maintainability of the application.</li><li>the Stable Dependencies Principle. Some components are designed to be volatile. We expect them to change. Any of these should not depend on a component that is difficult to change. We should depend in the direction of stability. Again employing the DIP can help us to apply this principle breaking dependency on a stable component.</li><li>the Stable Abstractions Principle. A component should be as abstract as it is stable. The software should encapsulates the high level policies (business rules) of the system into stable component. Those policies will become difficult to change. So how to make them flexible enough to withstand change ? By using Open Closed Principle and Abstract classes (personal note : I am not convinced by this advice of abstract classes &mldr;).
So the SDP says that dependencies should run in the direction of stability and the SAP says that stability implies abstraction. So dependencies should run in the direction of abstraction.</li></ul><p>Some links:</p><ul><li><a href=http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod>Summary of all these principles</a></li><li><a href=http://slideplayer.com/slide/10805390/>Slides : Principles of Package Design</a></li><li><a href=https://www.slideshare.net/blue9frog1/ood-principles-and-patterns>Slides : OOD Principles and Patterns</a></li></ul><h2 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h2><p>Uncle Bob views on architecture is somewhat different of the typical architect. For him, an architect continues to be a programmer. They may not write as much code but they continue to engage in programming tasks. They do this because they cannot do their jobs if they are not experiencing the problems that they are creating for the rest of the programmer.</p><p>The architecture of a software system is the shape given it by those who build it. The purpose of that shape is to facilitate development, deployment, operation and maintenance. The main strategy is to leave as many options as possible, for as long as possible. We should carefully separate policy from the details at the point that policy has no knowledge of the details. In more pragmatic words, the business rules should not depend on the technical details of implementation.</p><p>This leads us to draw boundary lines between components. Some of the components are core business rules, other are plugins that contains technical implementations. The DIP and SAP principles arrange dependency to point from lower-level details to higher-level abstractions (toward the core business).</p><p>The architecture chapters leads us to the <a href=https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>Clean Architecture</a> which is clearly the main advice of the book. Clean Architecture push us to separate stable business rules (higher-level abstractions) from volatile technical details (lower-level details), defining clear boundaries. The main building block is the Dependency Rule : source code dependencies must point only inward, toward higher-level policies.</p><p>It should have the following characteristics:</p><ul><li>Testable</li><li>Independent of frameworks</li><li>Independent of the UI</li><li>Independent of the database</li><li>Independent of any external agency</li></ul><p>This proposal is in fact build on the same ideas than <a href=http://alistair.cockburn.us/Hexagonal+architecture>Hexagonal Architecture</a> which proposed by Alistair Cockburn in 2005 and is more and more well known. Maybe because I am accustomed to it, Hexagonal Architecture proposition is more lean and straight to the point for me.</p><p>Some links to discover Hexagonal Architecture</p><ul><li><a href=http://fideloper.com/hexagonal-architecture>http://fideloper.com/hexagonal-architecture</a></li><li><a href=http://tpierrain.blogspot.fr/2016/04/hexagonal-layers.html>http://tpierrain.blogspot.fr/2016/04/hexagonal-layers.html</a></li><li><a href=http://alistair.cockburn.us/Hexagonal+Architecture+Live+in+Paris+with+Thomas+Pierrain>Videos of meetup around hexgonal architecture in Paris</a></li></ul><p>Interesting note from Uncle Bob, implementing many boundaries could be costly to implement (with all their abstractions and dependency inversions). So it&rsquo;s a real design decision. You don&rsquo;t simply decide at the start which boundaries to implement and which to ignore. It takes a watchful eye to monitor the system and introduce needed boundaries.</p><h2 id=details>Details<a hidden class=anchor aria-hidden=true href=#details>#</a></h2><p>In the last part and associated chapters, Uncle bob talks about technical details like Database, the Web or Frameworks and insists their are only details on which decisions should be delayed as far as possible.</p><p>There is also a case study and a chapter by Simon Brown which compare different code organisation : package by layer, feature or component. Most ideas can be found in this <a href=http://www.codingthearchitecture.com/2015/03/08/package_by_component_and_architecturally_aligned_testing.html>article of Simon Brown</a>.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>I am a bit disappointed by Clean architecture. Of course, it presents must known principles (SOLID) and build from them to present the &ldquo;component&rdquo; principles for software architecture (CCP, RRP, CRP, ADP, SAP, SDP). it also push strong opinions which I totally agree (like Software Architects should keep coding) and a Clean Architecture software structure which is very good structure.
However why not keep the hexagonal architecture proposal and propose improvements if necessary ?</p><p>My main feeling is that the book could easily summarised in a hundred of pages (the book is more than 350 pages). I think it could be made clearer and more straightforward. The design of the book leaves also an &ldquo;old school&rdquo; impression (what are these horrible chapter images ?). It also comes from the many old stories that want to bring some historical context on the subjet (but it could interest some people and brings some &ldquo;old wisdom&rdquo;).</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ygrenzinger.github.io/tags/book-summary/>book summary</a></li><li><a href=https://ygrenzinger.github.io/tags/architecture/>architecture</a></li><li><a href=https://ygrenzinger.github.io/tags/code/>code</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ygrenzinger.github.io/>Yannick Grenzinger</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>